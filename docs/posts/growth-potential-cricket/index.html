<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2026-01-17">

<title>Smart Investments in Cricket: Using Data to Measure Growth Potential</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-1d4f84655f446305ac42a8f1abcf7405.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Smart Investments in Cricket: Using Data to Measure Growth Potential</h1>
<p class="subtitle lead">How data science helps teams reduce risk when investing in player potential</p>
  <div class="quarto-categories">
    <div class="quarto-category">Cricket</div>
    <div class="quarto-category">Data Science</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 17, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction-the-high-stakes-of-getting-it-wrong" class="level3">
<h3 class="anchored" data-anchor-id="introduction-the-high-stakes-of-getting-it-wrong">1. Introduction: The High Stakes of Getting It Wrong</h3>
<p>Modern professional international and top-league cricket is a high-stakes business. Teams invest heavily in players through contracts, auctions, training programs, overseas tours, and long-term development pipelines. A single decision to back the wrong player can cost millions of dollars and years of lost competitive advantage.</p>
<p>Cricket leagues such as the Indian Premier League (IPL), Big Bash League (BBL), and The Hundred operate in multi-million-dollar ecosystems. In the 2026 IPL mini-auction alone, franchises spent over <strong>USD 26 million</strong> on 77 players, many of whom were young and relatively unproven. These investments are made long before a player’s true long-term value is known.</p>
<p>At the center of all these decisions lies a difficult question: <strong>how do teams identify which young player has the growth potential to become a future star?</strong> When teams get this wrong, the consequences extend beyond finances. Poor choices affect team balance and long-term planning.</p>
<hr>
</section>
<section id="the-problem-risky-bets-and-expensive-mistakes" class="level3">
<h3 class="anchored" data-anchor-id="the-problem-risky-bets-and-expensive-mistakes">2. The Problem: Risky Bets and Expensive Mistakes</h3>
<p>Talent identification in cricket is inherently uncertain. Teams are often forced to make early decisions using limited data, and a handful of good performances can quickly elevate a player’s reputation, while early failures may unfairly label another as a poor investment.</p>
<p>This creates a major challenge: <strong>short-term performance is not the same as growth potential</strong>. For instance, a batter might score heavily against weaker opposition or in favorable conditions, inflating their batting average. Similarly, a bowler might enjoy early success due to unfamiliarity or conditions that later disappear. This problem becomes clearer when early-career performance is visualized. Figure 1 shows two batters across their <strong>first 40 matches</strong>. At several points, both players appear to have similar batting averages. However, this similarity is misleading.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/batting_average_trends_40_matches.png" class="img-fluid figure-img"></p>
<figcaption>Fig:1 Batting average trends over time (first 40 matches)</figcaption>
</figure>
</div>
<p>Batsman B reaches these averages through sharp ups and downs, driven by a few high-scoring innings followed by multiple low scores. This inconsistency suggests that the performance is unstable and may not scale as the player gains experience. In contrast, Batsman A shows gradual improvement across the same number of matches. Even without dramatic standout performances, the steady upward trend indicates learning, adaptation, and stronger growth potential. This example highlights why relying on snapshot statistics such as current batting average can lead to poor investment decisions. Two players may look equally promising on paper, yet their underlying trajectories tell very different stories about who is likely to become a future star. The same logic applies to bowlers as well. Two bowlers may have taken a similar number of wickets after a given number of matches, making them appear equally valuable at first glance. However, a bowler who shows steady wicket accumulation as match experience increases is more likely to have higher growth potential than one whose success comes from a few isolated performances.</p>
<p>As a result, teams frequently make two costly errors. First, they overpay for players whose success is driven by temporary form rather than sustainable improvement. Second, they overlook players who develop steadily but without eye-catching performances early on. These overlooked players often flourish elsewhere, strengthening rival teams. The real problem is not a lack of talent, but the difficulty of distinguishing <strong>temporary success from genuine growth potential</strong>.</p>
<hr>
</section>
<section id="the-solution-a-data-driven-approach-to-growth-potential" class="level3">
<h3 class="anchored" data-anchor-id="the-solution-a-data-driven-approach-to-growth-potential">3. The Solution: A Data-Driven Approach to Growth Potential</h3>
<p>Data science offers a structured way to reduce this uncertainty. Instead of relying solely on intuition or recent performances, teams can analyze how players develop over time using historical data from their domestic competitions and international matches. This approach does not aim to replace coaches, selectors, or scouts. Rather, it supports them by highlighting long-term patterns that are difficult to detect from individual matches. By examining trends, consistency, and context, data analysis helps answer a more meaningful question: is this player improving in a way that suggests future success?</p>
<p>Importantly, a data-driven approach encourages patience. It allows teams to recognize slow but steady development and resist the temptation to chase short-term results. Focusing on growth potential shifts attention away from single standout performances and toward sustained development. It encourages teams to value learning, adaptability, and consistency, qualities that are often better indicators of long-term success than raw averages.</p>
<hr>
</section>
<section id="deep-dive-key-metrics-of-growth-potential" class="level3">
<h3 class="anchored" data-anchor-id="deep-dive-key-metrics-of-growth-potential">4. Deep Dive: Key Metrics of Growth Potential</h3>
<p>Analysis of historical player careers suggests that growth potential is best understood through <strong>patterns</strong>, not isolated statistics. Three metrics consistently provide useful insight into long-term development.</p>
<section id="metric-1-performance-trend-over-time" class="level4">
<h4 class="anchored" data-anchor-id="metric-1-performance-trend-over-time">Metric 1: Performance Trend Over Time</h4>
<p>A player’s trajectory matters more than their current numbers. Gradual improvement as the number of matches increases often signals learning and adaptation. Figure 1 highlights these early-career trends across the first 40 matches, where Batsman A improves steadily while Batsman B remains volatile.</p>
</section>
<section id="metric-2-long-term-output-and-accumulation" class="level4">
<h4 class="anchored" data-anchor-id="metric-2-long-term-output-and-accumulation">Metric 2: Long-Term Output and Accumulation</h4>
<p>Short-term form can be misleading. Looking at cumulative contribution reveals which players turn consistency into real value for their teams.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/batsman_runs_accumulation_100_matches.png" class="img-fluid figure-img"></p>
<figcaption>Fig:2 Batter run accumulation over career (matches played)</figcaption>
</figure>
</div>
<p>Figure 2 tracks total runs scored at <strong>20, 40, 60, 80, and 100 matches</strong>. Although Batsman D starts strongly, Batsman C’s steady development leads to higher long-term output. This demonstrates how consistent performance compounds over time, reinforcing the importance of growth potential. For young players who have not yet played many matches, these long-term curves are not used as direct benchmarks. Instead, teams compare a young player’s early accumulation pattern (for example, across the first 20–40 matches) with the early-career trajectories of successful past players. A young player whose accumulation curve resembles that of proven performers is more likely to possess strong growth potential, even if their current totals are modest.</p>
</section>
<section id="metric-3-consistency-and-recent-form" class="level4">
<h4 class="anchored" data-anchor-id="metric-3-consistency-and-recent-form">Metric 3: Consistency and Recent Form</h4>
<p>Extreme performances can distort overall averages. Rolling metrics help reduce this noise and provide a clearer view of sustained improvement.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/rolling_batting_average.png" class="img-fluid figure-img"></p>
<figcaption>Fig:3 Rolling batting average over time</figcaption>
</figure>
</div>
<p>Figure 3 shows rolling batting averages across matches. A smooth upward curve indicates reliable development, while frequent spikes and drops suggest instability. Rolling averages are particularly useful for identifying whether recent improvements are meaningful or temporary.</p>
<p>While these examples focus on batters, the same logic applies to bowlers. Early-career bowling averages or wicket tallies can also be misleading when viewed in isolation. A bowler who takes several wickets early due to favorable conditions may appear promising, but this success may not persist.In contrast, bowlers who show <strong>steady wicket accumulation</strong> in their first set of matches often go on to become reliable long-term performers.</p>
<hr>
</section>
</section>
<section id="the-risk-score-system-potentialmeter" class="level3">
<h3 class="anchored" data-anchor-id="the-risk-score-system-potentialmeter">5. The “Risk Score” System: PotentialMeter</h3>
<p>To turn these insights into actionable decisions, we propose <strong>PotentialMeter</strong>, a decision-support framework designed to summarize growth potential into a single, interpretable score. PotentialMeter uses a Gradient Boosting machine learning model that has the ability to capture complex and non-linear relationships in player development. This approach allows the model to learn subtle interactions between performance trends, consistency, and experience. In addition, PotentialMeter can compare a player’s early-career performance patterns with those of established top players or proven legends of the game. Players who show similar growth trajectories to successful past players are more likely to possess strong growth potential, even if their current performance levels are modest. One advantage of this framework is transparency. While the underlying model is complex, the output is simple: a score that reflects relative growth potential and long-term risk. This makes it easier for decision-makers to integrate data-driven insights into real-world discussions around contracts, auctions, and squad planning. Rather than predicting exact future statistics, PotentialMeter estimates the <strong>likelihood of improvement</strong>. This helps teams compare players with similar current performance and identify those with lower long-term risk. The resulting score is not a final decision, but a structured input that supports smarter investment choices.</p>
<hr>
</section>
<section id="conclusion-protecting-creativity-with-better-decisions" class="level3">
<h3 class="anchored" data-anchor-id="conclusion-protecting-creativity-with-better-decisions">6. Conclusion: Protecting Creativity with Better Decisions</h3>
<p>Data does not replace creativity, intuition, or experience in cricket. Instead, it protects them. By reducing uncertainty and highlighting meaningful patterns, data-driven analysis helps teams avoid costly overreactions to short-term form.</p>
<p>Growth potential is difficult to measure, but ignoring it can be even more expensive. Teams that rely solely on current performance risk missing the players who improve steadily and deliver long-term value. By combining traditional scouting with careful data analysis, teams can make better-informed decisions while still trusting expert judgement.</p>
<p>In an industry where one poor decision can cost millions, approaches like PotentialMeter help teams take <strong>smarter risks</strong>. The future of cricket talent identification lies in balancing human insight with data-driven evidence, investing not just in what a player has already done, but in who they are likely to become.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>